# 作业2说明文档

## 第1题
第1题要求，给定4个数后，输出所有可能的算式，使得能算出24，输出顺序不做要求，但是不能重复输出完全一样的运算方式。

由样例的输出可知：
1. 运算顺序全部由括号表示，4个数的运算需要3次，由于最后一次运算（最外层）不加括号，也就是出现2组括号。
2. 加法和乘法的交换顺序是算作不同的式子。

本题的算法思路是枚举和递归。

1. 先在这4个数中挑出2个数a和b（总共有C(4,2)=6种选法）
2. 对这2个数做4则运算，加上交换顺序，则共有8种可能的结果
3. 原先的4个数中删去这2个数，而把算得的结果作为第3个数放入原数列中
4. 重复上述操作，最后剩的1个数如果是24则保存运算方式

虽然对于4个数来说只需要3次运算，也就是上述操作中需要3次挑选数字，但是考虑到代码可拓展性，所以用了递归函数。递归的终点是数列中只剩1个数。

这样就可拓展至任意个数的数字，可算得任意的结果。但是我对于问题2的解法不是使用递归，具体在问题2中分析。

本题中我存储这些数所用的容器是vector<pair<double, string>> List

string是用于保存这个数是如何算出来的（也就是运算方式）。

初始化存入4个数时，double直接存入，string是存入to_string((int)double)，这里用int强制转换是为了不要存入小数点和后面的.0

递归函数中也是用这个容器，每次运算后就更新一次string。

举例：样例中给出2 3 5 10。

存入时，初始化每个元素为{2, "2"}, {3, "3"}, {5, "5"}, {10, "10"}

我通过递归，假定某次递归是选了2和3作加法2+3，那么就会更新这个容器为{5, "2+3"}, {5, "5"}, {10, "10"}

算法步骤2的实现方式是用了two()函数，返回值类型也是vector<pair<double, string>>，存入8个元素，对应8种运算结果

加括号的地方就是在此函数中实现，即判断挑出的元素的double和string是否一致。

若否，则意味着这个元素的数字是通过运算算出来的数字，则先在其外面套一层括号。

若是，则意味着这个元素的数字是原始数字，不是通过某个运算得出的结果，就不加括号了。

这样就能保证最外层不会有括号，且单个数字不会套个括号。

同样是上述例子，假如继续递归的某个操作是选了第一个5和10，则容器更新为{15, "(2+3)+10"}, {5, "5"}

递归终点时，剩下的元素的double就是最终运算结果，string就是运算式子。

使用set<string>容器expression存入符合结果的表达式，此类容器的好处是，set中的元素不会重复。

使用insert()函数，函数会自己判断是否在容器中已存在，不需要自己加个特判。

以样例为例，该程序的输出结果为
```
((10+5)-3)*2
((10-3)+5)*2
((5+10)-3)*2
((5-3)+10)*2
(10+(5-3))*2
(10+2)*(5-3)
(10-(3-5))*2
(2+10)*(5-3)
(5+(10-3))*2
(5-(3-10))*2
(5-3)*(10+2)
(5-3)*(2+10)
2*((10+5)-3)
2*((10-3)+5)
2*((5+10)-3)
2*((5-3)+10)
2*(10+(5-3))
2*(10-(3-5))
2*(5+(10-3))
2*(5-(3-10))
```
作业ppt给出的样例结果为
```
((10+5)-3)*2
(10+(5-3))*2
(10-(3-5))*2
((10-3)+5)*2
(10+2)*(5-3)
((5+10)-3)*2
(5+(10-3))*2
(5-(3-10))*2
((5-3)+10)*2
(5-3)*(10+2)
(5-3)*(2+10)
(2+10)*(5-3)
2*((10+5)-3)
2*(10+(5-3))
2*(10-(3-5))
2*((10-3)+5)
2*((5+10)-3)
2*(5+(10-3))
2*(5-(3-10))
2*((5-3)+10)
```
可以看到每一条是对应相同的，只是输出的顺序有些不同。

## 第2题
第2题的要求是运算符只限定为加号+和乘号*，运算顺序是从左到右，不改变原先输入数字的顺序，不考虑乘法的优先级，不加括号，且如果有，只需输出1种运算方式。

根据题意，每个数字用long long保存。

由于本题算法降低了要求，加之递归本身可能造成运行空间时间效率不高等等，于是本题不用递归，而是直接枚举，循环。

对于n个数，中间会插入(n-1)个运算符，而只有+和*，所以共有2的(n-1)次方个不同的运算符串

枚举这些运算符的方式是利用位运算（二进制），类似于短除法的原理，位数不足的补0（这里的0在函数中指补充"+"）在form()函数已经给出，生成string字符串tmp

calc()函数是通过给定的参数string运算符串即可算出结果。一共2的(n-1)次方次调用calc()函数，并更新大于D的最小运算结果MinResult。如果算出，则将所用的运算符串保存。

函数在计算时设置了提前返回的条件，由于是正整数且只是加法和乘法，则每次计算的结果总是不比上次结果小，从而如果早就超过了MinResult，则提前返回，结束运算

```cpp
const long long INF = 100000000000000003; // INF
long long D; // 目标值
long long MinResult = INF; //大于D的最小值 初始化为INF
```

保存了符合结果的运算符串，只需将原先给定的数字和运算符交替输出即可。

样例输出的结果与ppt给出的结果一致。
