# 作业3说明文档

主测试程序是main.cpp，直接对其进行编译运行即可。

本人对运行时间的测算数据，是通过在windows10系统，vscode的内置控制台运行程序所得。

为了方便测试N较大的情况，3个三维数组均设置为全局变量，MAXN设置为300。

为了方便操作，main.cpp使用了while(cin >> N)的方式，这样可多次输入不同的N值进行操作而且不需要重复运行exe文件。

若要跳出while循环，可以手动关闭运行，也可以输入字母等其他字符串从而终止while循环。

main.cpp将6种遍历方式设置为6个函数，在主函数中只需调用相应函数即可测得时间，方便调用。

在同一次运行中，首次对这3个三维数组a b c进行遍历访问和运算所需的时间比之后的每次操作的耗时更长。
此后的每次访问和操作所耗时长在误差范围内基本没有太大变化。

首次访问数组时多出来的时间主要是用于给数组开内存，测算结果也表明确实与MAXN的大小有关。
以draft1.cpp为例，MAXN设置为300，N每次输入时都是100，输入5次后结束程序，某次运行时的输出结果为：
```
ijk: 16
ijk: 6
ijk: 6
ijk: 5
ijk: 6
```
将MAXN改为150，N依然每次输入100，输出结果为：
```
ijk: 11
ijk: 6
ijk: 3
ijk: 4
ijk: 6
```
如上，首次访问的时长差别明显。

但是，在数组遍历方式一样，以及数组访问时机一样的情况下，访问的位置（外部函数调用或者直接在主函数访问运算）对耗时的影响不大。
具体可运行draft1.cpp和draft2.cpp进行对比，一个是放在test_ijk()函数，一个是直接写在main函数，结果是基本没有差别。

由此，main.cpp中采用函数调用的方式，不会对结果有大影响。

记录数据时，会剔除部分偏离较大的结果（首次访问数组时的结果是另外保存）。

举例。编译运行main.cpp，每次输入100，某次运行时的输出结果为：
```
N = 100
---test start---
ijk: 15
ijk: 3
ikj: 10
ikj: 10
jik: 8
jik: 8
jki: 6
jki: 5
kij: 17
kij: 51
kji: 21
kji: 18
---test over---
N = 100
---test start---
ijk: 7
ijk: 3
ikj: 4
ikj: 5
jik: 4
jik: 8
jki: 9
jki: 7
kij: 19
kij: 18
kji: 14
kji: 15
---test over---
N = 100
---test start---
ijk: 3
ijk: 3
ikj: 4
ikj: 5
jik: 3
jik: 3
jki: 9
jki: 5
kij: 17
kij: 16
kji: 16
kji: 17
---test over---
```
以这组数据为例，第12行（kij: 51）明显与其自身其他样本的偏离过大，剔除。

测试后所得的时长简单列表如下，时间的单位是ms，上面一行是首次访问的时长，下面一行是此后的访问所需的时长。

```
N=64
ijk       | ikj       | jik        | jki       | kij       | kji
6 7 6 4 4 | 6 5 5 6 7 | 6 6 5 10 9 | 6 5 5 6 6 | 5 6 6 6 7 | 6 6 6 7 8
1 2 1 1 1 | 1 3 1 2 4 | 1 1 2 0  2 | 2 2 2 1 1 | 2 2 2 1 2 | 2 3 2 2 1

N=128
ijk            | ikj            | jik            | jki            | kij            | kji
22 26 26 26 27 | 35 25 30 31 27 | 30 40 32 41 37 | 32 32 32 33 30 | 48 48 45 49 47 | 52 48 65 59 49
13 7  7  8  8  | 10 17 13 16 15 | 11 13 6  14 7  | 10 15 18 10 17 | 30 31 34 35 30 | 41 31 30 34 31

N=256
ijk                 | ikj                 | jik                 | jki                 | kij                 | kji
147 134 131 139 127 | 166 168 181 157 169 | 161 158 140 178 174 | 181 173 181 186 182 | 452 468 467 467 477 | 443 454 472 449 452
94  79  89  91  83  | 101 112 113 114 109 | 81  97  91  86  71  | 114 106 127 112 123 | 413 414 422 419 431 | 407 411 410 408 400
```

N在60及以下的范围内运行时，6种遍历方式的耗时基本是0ms或者1ms，没有太大的差别。

由上述数据可见：随着N的增大，遍历所需时长也随之增大。
N=64时，6种遍历方式的耗时区别不是特别明显。
N=128和N=256时，ijk遍历方式的耗时在6种遍历方式中耗时是总体排最小的（无论是首次访问还是后续访问）。jik也是比较小的，跟ijk差不多，比ijk稍大一些。
而kij和kji遍历方式的耗时总体是排最长的，与其他4种有着明显的差别。（此差别随着N的增大会更加明显，实际上我还测算了N=512的情况，但这时MAXN我设置为520，但并不能保证每次都能运行，因为要开内存比较大）

造成这种差别的原因是内存的cache（缓存）机制。计算机访问内存时会先访问缓存，缓存中会保存近期使用过的数据，读取速度快。
将内存中的内容读入缓存时，会将附近的一块数据都读入。
如果缓存中有要访问的内容，则缓存命中，直接读取。否则需要从内存中读取该内容。

先举个二维数组的例子。二维数组在内存中的存储方式是按行存储，也就是对于a[i][j]是按a[0][0], a[0][1], ...这一行存完然后存a[1][0], a[1][1]...
（n维数组都是从最内的维也就是第n维依次存储）

二维数组的遍历访问方式有2种，行遍历和列遍历（分别用ij和ji表示）。由于缓存读入时，会将附近的一块数据都读入。
而二维数组是按行存储，从而行遍历的命中率会更高，运行时间也就更少。而列遍历则命中率更低。

三维数组同理。ijk也就是对于第三维k的依次遍历，命中率最高，时间短。jik则排在其次，不过最内层也是按行遍历(k)，所以命中率也比较高。

而把第三维k放在最外层来遍历的两个遍历方式kij和kji则命中率最低，因而访问的耗时最长。
